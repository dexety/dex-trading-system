\section{Коннекторы}

Чтобы программа могла торговать, ей нужно подключиться к биржей. У выбранных нами бирж есть python-клиенты (python-binance и dydx-v3-python), позволяющие реализовать соединение. Итак, в нашем проекте есть 2 класса-коннектора, BinanceConnector и DydxConnector, с достаточно похожим функционалом.

\subsection{BinanceConnector}

\href{https://github.com/dexety/dex-trading-system/blob/main/connectors/binance/connector.py}{\texttt{BinanceConnector}}

\begin{definition}
Инструмент -- пара торгующихся на бирже валют
\end{definition}
\begin{definition}
Стакан -- таблица лимитных заявок на покупку и на продажу
\end{definition}

В конструкторе коннектор получает полученные из личного кабинета binance публичный и приватный ключи API для идентификации пользователя и список интересующих инструмент. Библиотека python-binance предоставляет класс синхронного клиента, Client. Методы этого класса используются в следующих функциях коннектора:

\begin{itemize}
    \item \texttt{get\_all\_balances} -- получение информации о балансе аккаунта.
    \item \texttt{get\_cached\_symbol\_info} -- получение информации о маркете (например tick-size цены и количества)
    \item \texttt{get\_cached\_order\_book} -- получение состояния стакана (для реализации существует отдельный класс, кэширующий приходящие обновления стакана)
    \item \texttt{send\_limit\_order/send\_ioc\_order} -- создание ордера. Больше функций по отправке ордера не реализовано, потому что коннектор бинанса в последствии использовался только для мониторинга данных.
    \item \texttt{cancel\_order} -- отмена ордера по id, которое мы задали при создании.
    \item \texttt{get\_*historical*\_trades} -- сбор исторических данных по проведенным сделкам.
    \item и т. д.
\end{itemize}

Также в python-binance есть классы AsyncClient и BinanceSocketManager для оформления подписки на совершенные сделки и на обновления стакана. Ключевая функция -- \texttt{\_subscribe\_exchange\_data}, которая подписывается на совершенные сделки и на обновления стакана для каждого указанного в конструкторе маркета и начинает ждать и обрабатывать приходящие апдэйты. Функция асинхронная, потому что пока получаем обновления, мы хотим иметь возможность вовремя отправить ордер, или наоборот его отменить.

Для того, чтобы было удобно "слушать" информацию через коннектор, реализован концепт функции-listener.

\begin{designation}
Листенер -- функция, которая вызывается из коннектора при получении им обновлений. Листенеры "слушают"\ обновления.
\end{designation}

\begin{itemize}
    \item \texttt{add\_*\_listener} -- добавление кастомного листенера в список. При получении коннектором соответсвующего обновления, все листенеры из этого списка будут вызваны с апдэйтом в аргументе.
    \item \texttt{\_call\_*\_listeners} -- вспомогательная функция. Вызывается при получении коннектором соответсвующего обновления. Вызывает все добавленные листенеры с апдэйтом в аргументе функции.
\end{itemize}

Функции start и \_async\_start используются для активации коннектора, подписки на интересующие потоки и начала получения обновлений.

\subsection{DydxConnector}

\href{https://github.com/dexety/dex-trading-system/blob/main/connectors/dydx/connector.py}{\texttt{DydxConnector}}

Коннетор для dydx очень похож на BinanceConnector, но более приспособлен к торговле, так как именно через него мы размещали ордеры.

 В коннекторе для dydx, как и binance, создается элемент класса \texttt{Client} с несколькими аргументами. Для удобста задания полей коннектора есть впомогательный датакласс Network и список элементов этого класса с заданными полями для сетей mainnet и ropsten. Так, при создании коннектора, в аргументах нужно всего лишь указать название сети. Для тестирования используется сеть ropsten, для реальных торгов - mainnet.

В целом, интерфейс коннектора для dydx очень похож на интерфейс коннектора для binance. Тут тоже есть функции, вызывающие синхронные методы клиента:

\begin{itemize}
    \item \texttt{get\_symbol\_info} -- получение информации о маркете
    \item \texttt{get\_order\_book} -- получение состояния стакана
    \item \texttt{get\_our\_positions/get\_our\_orders} -- получение информации о имеющихся позициях и выставленных нами ордеров
    \item \texttt{send\_*\_order} -- создание ордера. DydxConnector лучше приспособлен к торговле, поэтому реализовано 4 вида функции по созданию ордера. \texttt{send\_limit\_order} - лимитная заявка; \texttt{send\_trailing\_stop\_order} -- stop-loss ордер, который переставляется ближе к рыночной цене, если она идет в благоприятную для нас сторону; \texttt{send\_take\_profit\_order} - лимитная заявка, использующаяся для фиксирования прибыли; \texttt{send\_market\_order} - ордер по рыночной цене.
    \item \texttt{cancel\_order/cancel\_all\_orders} -- отмена ордера по id, заданному нами при создании/отмена всех наших ордеров.
    \item \texttt{get\_historical\_trades} -- сбор исторических данных по проведенным сделкам.
    \item и т. д.
\end{itemize}

Для подписки и прослушивания обновлений используется python-модуль websockets и, как и в BinaceConnector, функции-listener.

\begin{itemize}
    \item \texttt{add\_orderbook/trade/account\_listener} - добавление листенера на обновления стакана/сделок/аккаунта.
    \item \texttt{add\_orderbook/trade/account\_subscription} - добавление запроса на подписку на обновления стакана/сделок/аккаунта в список запросов на подписку.
    \item \texttt{\_call\_orderbook/trade/account\_listener} - вспомогательная функция. Вызывается при получении коннектором соответсвующего обновления. Вызывает все добавленные листенеры с апдэйтом в аргументе функции.
\end{itemize}

Таким образом, если, например, программе нужно прослушивать обновления стакана для маркета \\MARKET\_ETH\_USD, то перед запуском коннектора функцией start или async\_start нужно добавить соответсвующие листенеры и подписку.

\begin{verbatim}
    #!\bin\python3
    ...
    add_orderbook_listener(orderbook_listener)
    add_orderbook_subscription(MARKET_ETH_USD)
    ...
\end{verbatim}

Есть аналогичная с BinanceConnector асинхронная функция \texttt{subscribe\_exchange\_data}. В ней сначала оформляются подписки на интересующие нас обновления путем отправки запросов из заполненного ранее списка запросов на подписку. Затем функция начинает получать обновления и вызывать соответствующие листенеры.

Если dydx фиксирует слишком большую активность от одного клиента, то клиент получает трехсекундный бан. Во время бана отправление и отмена ордеров невозможна, что может привести к потере реальных денег. Для избежания таких ситуаций был реализован декоратор \texttt{safe\_execute}, который в случае поимки исключения при исполнении функции будет пытаться исполнить ее до 50 раз, пока функция не завершится корректно.

\input{sections/latency}

